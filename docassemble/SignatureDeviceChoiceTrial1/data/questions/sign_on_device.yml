metadata:
  title: Device choice for signature
  short: Signature via device

# DEVELOPER: Include this at the top of your script before your other code.
# You can customize this and override the text and code in here.
# Shared content and functionality will continue to be worked on and improved,
# as well as translated, so it might be worth keeping what you can.

# Justification for file name: It's the only variable name needed to trigger this whole thing
# Disclaimer: I'm not quite sure how to utlize `force_action()`. For now, it's just a way to make sure the user can't go back.

# TODO: Prevent original device from accidentally opening the signature page?
# TODO: Allow user to explicitly go back to their original device.
# TODO: Add error message for wrong number
# TODO: Provide email option too?
# TODO: `task_not_yet_performed('send signature link')` - allow only one sending of the link or allow for mistakes?
---
modules:  
  - docassemble.VirtualCourtToolbox.shortenURL
---
# If needed, offer them a way to send the link to another device.
# Direct them to the signature.
id: generic signature flow
event: x.sign_on_device
generic object: Individual
code: |
  log( x.signature_device_id, 'console' )
  x_var_name = x.instanceName
  x.correct_current_device = x.current_device_id == x.signature_device_id
  log( 'correct current device', 'console' )
  log( x.correct_current_device, 'console' )
  
  was_from_an_action = not action_argument() is None
  x.correct_action_id = was_from_an_action and action_argument( 'device_id' ) == x.signature_device_id
  log( 'was_from_an_action' )
  log( was_from_an_action )
  
  # TERMINAL CASE: If has signed already, skip to end
  if defined( x_var_name + '.signature' ):
    x.has_signed = True
    x.signature_date = today()
    force_ask( x_var_name + '.after_signature' )

  # If this is the correct device on which to sign
  # This logic needs some more examination
  elif x.correct_current_device or x.correct_action_id:
    if x.wants_this_device:
      # Invalidate all other devices
      if not x.correct_current_device:        
        x.signature_device_id = get_random_id()
        x.current_device_id = x.signature_device_id
        
      # (Include status on 'willing' page? Wrong focus?)
      if x.willing_to_sign:
        # In case they changed their mind on a different device between screens
        if x.correct_current_device or x.correct_action_id:
          x.signature  # Should only be defined once

    # if wants a different device
    else:
      # Prevent this or another invalidated device from signing
      log( '1: ' + x.signature_device_id, 'console' )
      if x.send_signature_link_method:

        if x.send_signature_link_method == 'sms':
          log( 'reconsidering sms', 'console' )
          x.send_sms_signature_link
        elif x.send_signature_link_method == 'email':
          log( 'reconsidering email', 'console' )
          x.send_email_signature_link

        log( 'passed link method: ' + x.send_signature_link_method, 'console' )
        # Invalidate past devices, reset values so they can be asked again?
        
        x.signature_device_id = get_random_id()
        undefine( x_var_name + '.reset_device_choice' )
        x.reset_device_choice

  # Interaction is not on the signature device right now
  else:
    x.wants_device_redo
    #if x.wants_device_redo is True:
    #  # Prevent this or another invalidated device from signing
    #  # How to handle an old device they want to come back to?
    #  # Invalidate other devices
    #  # TODO: Redo this bit too with force_ask()? Don't think it'll work because
    #  # need the current device to be correct.
    #  x.signature_device_id = get_random_id()
    #  x.current_device_id = x.signature_device_id
    #  # Invalidate past devices, reset values so they can be asked again?
    #  #force_ask(
    #  #  { 'recompute': [ x.instanceName + '.set_new_device_id' ] },
    #  #  { 'recompute': [ x.instanceName + '.reset_device_choice' ] },
    #  #  x_var_name + '.sign_on_device'
    #  #)

  # Always loop again till TERMINAL CASE
  #force_ask( x_var_name + '.sign_on_device' )
  # vvv Maybe this instead, but I don't think so vvv
  #force_ask(
  #  { 'recompute': [ x.instanceName + '.reset_device_choice' ] },
  #  x_var_name + '.sign_on_device'
  #)
---
generic object: Individual
code: |
  x.signature_device_id = get_random_id()
  log( 'new device id', 'console' )
  log( x.signature_device_id, 'console' )
  x.set_new_device_id = True
---
generic object: Individual
code: |
  log( 'asking for x.signature_device_id', 'console' )
  # The id for the device that is allowed to get the signature right now
  x.signature_device_id = get_random_id()
  x.current_device_id = x.signature_device_id # gets us through the first loop
  log( x.signature_device_id, 'console' )
---
id: signature
generic object: Individual
question: |
  Sign your name
signature: x.signature
under: |
  ${ x }
---
id: after signature
generic object: Individual
event: x.after_signature
question: |
  Thank you ${ x }
buttons:
  - Exit: exit
  - Restart: restart
---
id: wants this device?
generic object: Individual
question: |
  Do you want to sign on this device?
subquestion: |
  You can sign somewhere else if you want, like on a different computer or phone.
yesno: x.wants_this_device
---
id: willing to sign
generic object: Individual
question: |
  Are you willing to sign this document?
yesno: x.willing_to_sign
---
id: where to sign
generic object: Individual
question: |
  Choose the way you want to sign this document
fields:
  - note: |
      You can use this QR code:

      ${ x.url_as_qr }
  - Send this to a different device: x.send_signature_link_method
    datatype: radio
    required: False
    choices:
      - By email: email
      - By text: sms
  - What email address?: x.email
    datatype: email
    js show if: |
      val('x.send_signature_link_method') == 'email'
  - What is their phone number?: x.mobile_number
    js show if: |
      val('x.send_signature_link_method') == 'sms'
---
generic object: Individual
code: |
  log('sending sms', 'console')
  x.signature_link_result = send_sms(task='send sms signature link', to=x.mobile_number, template=x.sms_template)
  x.send_sms_signature_link = True
---
generic object: Individual
code: |
  log('sending email', 'console')
  x.signature_link_result = send_email(task='send email signature link', to=x, template=x.email_template)
  x.send_email_signature_link = True
---
generic object: Individual
code: |
  url = interview_url_action(SIGNATURE_EVENT, signer_id=x.signer_id, device_id=x.signature_device_id)
  x.url = shortenMe( url ).shortenedURL
---
generic object: Individual
code: |
  # Transition to the below
  x.url_as_qr = interview_url_action_as_qr(SIGNATURE_EVENT, signer_id=x.signer_id, device_id=x.signature_device_id)
---
# constant
code: |
  SIGNATURE_EVENT = 'request_signature'
---
# Gives a unique id to the individual that the interview will recognize.
generic object: Individual
code: |
  x.signer_id = get_random_id()
---
id: generic sms template
generic object: Individual
template: x.sms_template
content: |
  Dear ${ x },
  Your signature is needed on a document.
  ${ x.url }
---
id: generic email template
generic object: Individual
template: x.email_template
content: |
  Dear ${ x },
  Your signature is needed on a document.
  
  ${ x.url }

  You can also use this QR code:

  ${ x.url_as_qr }
---
id: waiting for signature
generic object: Individual
question: |
  We are waiting for a signature on another device
subquestion: |
  When you are done signing on the other device you can keep going.
  
  Do you want to pick a different device to sign on?
yesno: x.wants_device_redo
---
generic object: Individual
# I know `undefine()` can take multiple arguments, but it looks messier
code: |
  undefine( x.instanceName + '.wants_this_device' )
  undefine( x.instanceName + '.willing_to_sign' )
  undefine( x.instanceName + '.send_signature_link_method' )
  undefine( x.instanceName + '.send_sms_signature_link' )
  undefine( x.instanceName + '.send_email_signature_link' )
  undefine( x.instanceName + '.wants_device_redo' )

  x.reset_device_choice = True
---
code: |
  import random
  import string
  def get_random_id(num_chars=10):
    return ''.join(random.choice(string.ascii_lowercase) for i in range(num_chars))
---
